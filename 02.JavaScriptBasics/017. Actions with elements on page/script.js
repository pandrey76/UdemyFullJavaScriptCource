let box = document.getElementById('box'),
    btn = document.getElementsByTagName('button'),
    circle = document.getElementsByClassName('circle'),
    heart = document.querySelectorAll('.heart');


// Меняем цвет нашего первого квадрата
// Запись цвета может быть в формате RGB, Hex или
// в виде строки.
   box.style.backgroundColor = 'blue';
// Обратите внимание как мы написали это свойство,
// если мы прописывали это в css, то здесь была бы запись:
// background-Color, в JS всё прописывае тся в формате CamelCase.

// Если изначально вы не уверены как правильно написать какое-то css свойство,
// то можно воспользоватся google. Если забить просто "background" в поисковике,
// то одна з первых ссылок будет на сайт htmlbook.ru. Обычно в таких статьях
// после всего описания свойство есть такая вещь как добратся до этого стиля
// "Объектная модель".

// Меняем форму второй кнопки, в виде окружности.
// Свойство вводится только в виде строки!
    btn[1].style.borderRadius = '100%';

// Меняем цвет кругов
// Делаем светофор
    circle[0].style.backgroundColor = 'red';
    circle[1].style.backgroundColor = 'yellow';
    circle[2].style.backgroundColor = 'green';

// Так по разному мы можем менять различные элементы, причём несколько
// разных стилей можно применять к одному элементу.
// Но если нам необходимо провести одинаковое действие над каждым элементом
// из псевдомассива, то мы можем использовать цикле

    for(let i = 0; i < btn.length; i++)
    {
        btn[i].style.background = 'red';
    }

    for(let i = 0; i < heart.length; i++)
    {
        heart[i].style.backgroundColor = 'blue';
    }

// Для селекторов, есть более правильный способ работы с элементам в цикле
// Цикл forEach
// Как ранее говорилось необходимо прописать callBack функцию, которая
// строго выполнится после предыдущей, forEach это тоже функция, поэтому сначала
// выполняется forEach, потом та которая прописана внутри.
// Третий аргумент у функции это сам массив, который мы передаём, однако его
// нужно называть по другому.
    heart.forEach(function(item, i, hearts){
        item.style.backgroundColor = 'blue';
    });

// Следующим нашим шагом будет изучение основных методов для работы с элементами
// страницы, очень часто части сайта создаются (генерируются) при помощи
// JavaScript на таких принципах построен React и мы должны уметь создавать
// новые элементы прямо на лету.
// Для того, чтобы создать элемент используется следующий метод:

 let div = document.createElement('div');

    console.log(div);  // <div></div>

// Иногда необходимо создавать и текстовые узлы, это такие элементы без
// оболочек тэга
 let text = document.createTextNode('Здесь был я!');
 console.log(text);     // Здесь был я!

// У нас есть элемент div и, что же мы можем с ним сделать дальше, мы можем его
// стилизовать, добавить визуальной оболочки. Если мы хотим поменять элемент
// координальным образом, то чаще всего мы не переписываем кучу конструкций со
// Style, мы добавляем класс модификатор из css, который будет прописан именно
// в css файле. Давайте так и поступим. Для того, чтобы манипулировать классами
// раньше существовало довольно простое свойство, которое называлось className,
// где мы можем указать через пробел классы и добавить к элементу, но его не
// рекомендуется использовать и даже если его где-то увидите это савсем
// устаревший способ и этот метод очень не удобен в работе.
// Вместо этого есть давольно мощьное средство, которое называется classList,
// где мы через точку осуществляем действие с нашим классом, это удаление,
// добавление, переключение (toggle), проверка на содержание или даже
// определение колличества применнённых классов к элементу.

div.classList.add('black');
console.log(div);  // <div class="black"></div>

// Метод toggle, который позволяет нам переключать класс в зависимости от
// каких-то действий.
// Наш элемент создан, он имеет какие-то стили, но сейчас он лежит в
// нашей коробке, которая есть только в javaScript, к html он никакого
// отношения не имеет и на странице его нету.
// Воспользуемся нашим деревом DOM и изменим это. Дело в том, что
// любой элемент можно вставить в конец, вставить после определённого
// элемента, удалить или заменить, но только по отношению к родителю.

//Обращаемся к тэгу (body) и всавляем наш элемент в конец.
document.body.appendChild(div);


let wrapper = document.querySelector('.wrapper');
// элемент можно добавить только один раз, т.е. элемент наш div
// добавится всего лишь один раз в элемент Wrapper

wrapper.appendChild(div);

document.body.insertBefore(div, circle[0]);
// Если мы не укажем второй параметр метода "insertBefore",
// то этот метод сработает как appendChild, который мы рассматривали
// немножко раньше.

// Чтобы удалить элемент со страницы мы можем воспользоватся методом
// removeChild.
document.body.removeChild(circle[1]);

let wrapHeart = document.querySelectorAll('.wrapper .heart');
wrapper.removeChild(wrapHeart[1]);

// Есть ещё один метод, который называется 'replaceChild' и используется он
// для замены одного элемента другим.

document.body.replaceChild(
                            btn[3], // То, что мы хотим поместить
                            circle[1]// То, что мы хотим заменить
);

// Все эти методы достаточно простые, но они также работают на реальных
// страницах.
// Добавление текст или даже html кода в элементы.
// Существует метод, который называется innerHtml, который как раз
// добавляет html код на страницу.

div.innerHTML = 'Hello World!';
// Мы вставили текст на страницу, однако если мы хотим вставить вёрстку,
// то наш текст должен лежать в тэге.
div.innerHTML = '<h1>Hello World!</h1>';
// Теперь в нашем блоке  div class="black"></div> дежит блок
// <h1>Hello World!</h1>, это работает и так мы можем формировать
// разные структуры, целую вёрстку, но если вдруг текст мы получаем
// от польз ователя и мы хотим вставить на страницу, соответственно
// мы хотим получить имено текст, ведь никто не помешает пользователю
// добавить код или вредноносный скрипт, для того чтобы обезапасить страницу
// и быть уверенным, что появится только текст используется другой метод,
// который называется "textContent"

div.textContent = 'Hello World!';
// Мы видим, что на результат это никак не повлияло, но теперь мы добавили
// имено текст, таким образом мы обезопасили нашу страницу