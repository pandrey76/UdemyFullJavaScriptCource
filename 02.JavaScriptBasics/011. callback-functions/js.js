function first() {
    // Что-то делаем
    // В этой функции возможно будут какие-нибудь действия,
    // здесь упор делается на то, что эта функция будет выполнять
    // какие-нибудь действия, которые занимают определённое время.
    // Здесь используется специальная структура, которая делает
    // задержку на пол секунды, это может быть общение с сервером,
    // это может быть выполнение очень сложной бизнес логике,
    // Однако эта функция работает с небольшой задержкой

    setTimeout(function () {
        console.log(1);
        }, 500);

}
// Функция просто выводит в консоль цифру 2.
function second() {
    console.log(2);
}
first();
second();
// Первая функция выводит 1 вторая 2 и мы расчитываем,
// что сначала вызовется первая, а потом вторая,
// но мы видим, что сначала в консоль выводится 2 и только потом 1.
// Почему-то вторая функция сработала быстрее первой, хотя в коде это не так.
// Мы видим, что если вызывать функции просто одну за другой, особенно если они
// работают с общими данными, то мы можем получить совершенно другой результат.
// Если говорить простым языком, то callback - это функция,
// которая должна быть выполнена после того, как другая функция
// завершила своё выполнение, т.е. если в нашем коде мы хотим
// чтобы вторая функция выполнилась только после первой,
// то мы должны её задать как callback функцию.
// Даваёте рассмотрим на примере, как это может происходить,
// сразу необходимо сказать, что в качестве аргумента любая
// функция может взять другую функцию и вот она уже будет
// называтся callback функцией.

// Напишем такую конструкцию:
function learnJS(lang, callback) {
    console.log("Я учу " + lang);
// Теперь при вызове функции "lernJS" у нас будет выводится
// в консоль сообщение, но т.к. мы передали ещё callback,
// то мы можем его взять и вызвать внутри функции.
callback();
}
// Теперь когда мы захотим вызвать функцию learnJS,
// то мы можем передать туда два параметра. первый это тот язык,
// который мы сейчас изучаем ("JavaScript") и т.к.
// вторым аргументом у нас идёт "callback" и мы его вызывали в теле функции,
// значит предполагается, что вторым аргументом будет функция,
// поэтому мы пишем следующее:callback функцию можно задать
learnJS("JavaScript", function () {
    console.log("Я прошёл 3-й урок");
});
// После вызова функции "learnJS", сначала выводится сообщение
// "Я учу JavaScript", т.е. стандартная функция отработала,
// вторая строка это "Я прошёл 3-й урок", а это означает,
// что вторая функция, которую мы передали как callback
// выполнилась чётко после выполнения первой функции. Как раз этого мы и хотели.
// Между прочим callback функцию можно задать и в не вызова функции и просто
// передавать туда готовый результат.

function done() {
    console.log("Я прошёл 3-й урок");
}
learnJS("JavaScript", done);

// После вызова функции learnJS мы получим такой же результат,
// как при предыдущем вызове функции learnJS, причём заметьте особенность,
// что в качестве параметра мы передали не вызов функции done ( done() ), а
// именно саму функцию, чтобы она потом выполнилась и дала какой-нибудь
// результат.

// В общем callbacks позволяют нам быть уверенными, в том, что определённый
// код не начнёт исполнение до того момента пока другой код не завершит
// своё исполнение.
