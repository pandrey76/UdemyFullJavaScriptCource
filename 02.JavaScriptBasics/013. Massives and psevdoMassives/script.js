
let options = {
    width:  1024,   // какая-нибудь ширина
    height: 1024,    // какая-нибудь высота
    name:   "test", // какое-нибудь имя
};
console.log(options.name);  // Выведется: test
options.bool = false;
options.colors = {
    border: "black",
    bg: "red",
};
delete options.bool;
console.log(options);
for(let key in options){
    console.log('Свойство ' + key + ' имеет значение ' + options[key]);
}
console.log(Object.keys(options).length);

// Массивы это такие структуры, которые содержат элементы по порядку
// Это может быть масив с моими вкладками в браузере имено с их адресами
// или набор каких то функций, или даже смешанный масив с разными данными
// чаще всего мы хотим добавить или удалить элемент из нашего масива.
// У нас есть методы для работы с концом масива и с его началом.

let arr = [1, 2, 3, 4, 5];
console.log(arr);   // Выведется:   [ 1, 2, 3, 4, 5 ]

// Для того чтобы удалить элемент из масива с конца, т.е. последний элемент
// у нас есть команда "pop".
arr.pop();
console.log(arr);   // Выведется:   [ 1, 2, 3, 4 ]

// добавляем элемент в масив
// 5, но уже в виде строки
arr.push("5");
console.log(arr);   // Выведется:   [ 1, 2, 3, 4, '5' ]

// Используем метод shift, для удаления первого элемента из масива
arr.shift();
console.log(arr);   // Выведется:   [ 2, 3, 4, '5' ]

// Добавляем элемент в начало масива
arr.unshift("1");
console.log(arr);   // Выведется:   [ '1', 2, 3, 4, '5' ]

// Перебираем элементы в масиве
for (let i = 0; i < arr.length; i++)
{
    console.log(arr[i]);    // Выведется:
                            //    1
                            //    2
                            //    3
                            //    4
                            //     5
}
// Мы указали свойство масивов "length", то стоит отметить, что
// для масивов это свойство работает немного по другому.
// Мы должны понимать, что в масиве могут содержатся элементы с
// разными порядковыми числами, т.е. если я запишу "arr[99] ="  это значит
// что я создаю 99 элемент в нашем масиве
arr[99] = 99;
console.log(arr);   // [ '1', 2, 3, 4, '5', <94 empty items>, 99 ]
// Запись типа "arr[99] = 99;" является грубой ошибкой. Мы никогда не должны
// указывать строго номер каого-нибудь элемента в масиве иначе это
// может привести к появлению пустых элементов в
// нашем масиве ("[ '1', 2, 3, 4, '5', <94 empty items>, 99 ]").
// В этом главная суть масива, все элементы должны быть по порядку.
// Хотя на практике бывают случаи, когда это не всегда так, но
// всё же необходимо придерживатся канонов.
// Однако сейчас мы написали эту структуру (arr[99] = 99;) не совсем для этого
// если вывести длину нашего масива, тоесть количество элементов
// в нашем масиве, то мы получим значение 100.
console.log(arr.length);    //  100
// Хотя в нашем масиве всего 6 элементов, дело в том, что такая
// команда как "length" нам возвращает не количество элементов в
// нашем масиве, а последний индекс плюс один и мы должны помнить
// об этой особенности когда будем работать с масивами.
arr[0] = "firstElem";
arr[3] = "fourthElem";
// И есть ещё один способ перебора нашего масива, и это forEach
// forEach используется так, мы пишем имя нашего масива, к которому
// мы хотим примсенить forEach, далее идёт метод forEach и так как это метод
// так как это какое-то действие мы открываем круглые скобки, здесь мы будем
// использовать такое понятие  как callback функция, мы берём каждый элемент
// из масива и применяем к нему эту функцию, которую мы напишем в круглых
// скобках. Наша функция внутри forEach может принимать три аргумента:
//      Первый - это item, каждый элемент, который будет в нашем масиве;
//      Второй - номер нашего элемента (например: i, здесь может быть любое
//               имя элемента и оно потом будет использоватся далее в функции);
//      Третий - это сам масив, например mass1.
// Если в работе этой функции нам нужны только элементы, которые мы перебираем,
// то оставшиеся два аргумента нам не нужны, если нам необходим номер элемента,
// то нам необходимо будет задать два первых аргумента. Потому что синтаксис
// такой, первым всегда идёт перебирающийся элемент, вторым идет порядковый
// номер, а третим как раз тот масив который мы используем.
// Немного о названиях аргументов старайтесь всётаки не использовать названия
// кикие уже были, либо какие-то готовые команды, например console, т.к. это
// может привести к неработающему на старых браузерах коду.
arr.forEach(function (item, i, mass1) {
    // Здесь мы будем прописывать , то действие, которое должно произойти.
    // Например:
    console.log(i + ':' + item + " (массив: " + mass1 + ')');    // Выведется:
            // 0:firstElem (массив: firstElem,2,3,fourthElem,5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,99)
            // 1:2 (массив: firstElem,2,3,fourthElem,5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,99)
            // 2:3 (массив: firstElem,2,3,fourthElem,5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,99)
            // 3:fourthElem (массив: firstElem,2,3,fourthElem,5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,99)
            // 4:5 (массив: firstElem,2,3,fourthElem,5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,99)
            // 99:99 (массив: firstElem,2,3,fourthElem,5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,99)

    // Наша callback функция выполнится только тогда, когда запустится метод
    // forEach
});

// Теперь рассмотрим самый новый способ перебора масива
// Цикл forOff он перебирает имено значения в том элементе, который мы берём,
// срузу необходимо сказать, что он не работает с объектами. Он обычно может
// использоватся в масивах, стороках и новых видах объектов которые появились
// в новом стандарте (map, set и т.д.).

let mass = [1, 3, 4, 6, 7];

// наш старый знакомый for in
for (let key in mass) {
    console.log(key);   // Выведется:
                        //    0
                        //    1
                        //    2
                        //    3
                        //    4
// Так как объекты это последовательность элементов Ключ: Значение;, то
// масивы это разновидность объектов и у элементов тоже есть Ключ и Значение.
// Ключ у первого элемента масива это 0, другими словами это идекс элемента.
}

for (let key of mass){
    console.log(key);   // Выведется:
                        //    1
                        //    3
                        //    4
                        //    6
                        //    7
// Здесь мы видим, что с помощью цикла for of мы выведем
// значения элементов масива
}
// Существует ещё несколько для трансформации масива, через callback функцию, но
// используется крайне редко, это filter, map, every, some и reduce.
// Необходимо самостоятельно ознакомится с этими способами.
// А реально используемые методы, это split, sort и join.
// представим, что мы получили большую строку, где через какой-нибудь знак
// препинания написаны товары. Мы их хотим поместить сразу в массив и здесь
// нам приходит на помощь метод split.

// Вводим: "arrr,tt,qqq,www"
let ans = prompt("", "");
    arr = [];
arr = ans.split(',');
console.log(arr);   // Выведется массив: ["arrr", "tt", "qqq", "www "]
// Всё, что мы попросили ввести пользователя через запятую трансформировалось
// в массив
// Но иногда нам надо сделать наоборот, мы хотим взять наш массив и отправить
// его одной строкой, например на сервер.

let arr1 = ["aawe", 'zzz', 'pp', 'rqa'];
    let i = arr1.join(', ');

console.log(i); // Выведется строка:  "aawe, zzz, pp, rqa"

// С помощью этих двух методов можно манипулировать не только строками, но
// и массивами.

// Если нам необходимо отсортировать наш массив по алфовиту мы можем
// использовать метод "sort"

let arr2 = ["aawe", 'zzz', 'pp', 'rqa'];

    arr2.sort();

console.log(arr2); // Выведется массив:  ["aawe", "pp", "rqa", "zzz"]

// Изначально "sort" сортирует по алфовиту, если это строки, то всё нормально,
// если это цифры, то это приведёт к проблемам

let arr3 = [1, 15, 4];
arr3.sort();
console.log(arr3); // Выведется массив:  [1, 15, 4]
// Как мы видим ничего не изменилось, т.к. этот метод сортирует всё как строки
// и сравнивает элементы по первым значениям

let arr4 = [5, 15, 4];
arr4.sort();
console.log(arr4); // Выведется массив:  [15, 4, 5]

// Для того, чтобы метод сорт работал правильно с цифрами ему надо передать
// callback функцию во внутрь sort.

function compareNum(a, b) {
    return a-b;
}
// мы должны передать имено функцию, а не её результат
let j = arr4.sort(compareNum);
console.log(arr4); // Выведется массив:  [4, 5, 15]
// это всё работает так, сам язык JavaScript работает по своим алгоритмам
// и функция sort основана на алгоритме быстрой сортировки это не простая вещь,
// можно посиотреть по ссылке в текущей директории
// "13.1 Полное описание массивов.html" там есть описание этого алгоритма.
// Если говорить очень отдалённо, то он просто ориентируется на разницу
// между двумя элементами масива, которые туда передаётся она либо
// положительная, либо отрицательная и так сравнивается каждый элемент
// масива.
// Это основные методы работы с массивами, которые мы будем чаще
// всего использовать.

//  Есть ещё такое понятие как Псевдомасивы.
// Все frontend разработчики с ними часто сталкиваются при работе с
// элементами на странице. Псевдомассив - это объект, структура, которая
// совпадает со структурой масива, т.е. по сути это тоже самое, он
// хранит элементы в индексах, но при этом псевдомассив не обладает методами
// свойственными полноценным массивам из-за отличий в своём прототипе, т.е.
// у псевдомассива нет всех методов, которые мы рассмотрели ранее, не "push",
// не "sort" и т.д. Если мы вспомним как строится страница в html, то там
// могут быть десятки одинаковых тэгов, классов, аттрибутов и т.д. и например мы
// можем сформировать псевдомассив с набором элементов с одинаковыми тэгами
// к примеру. На следующем занятии мы будем получать эти html коллекции, т.е.
// псевдомассивы со страницы, но нам сейчас уже надо понимать чем они отличаются
// от обычных массивов.